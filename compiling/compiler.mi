import dev

// Open input file (read as string)
FILE* code = open("mini.mi", "r")
code = read(code)
POS = skipWS(0, code)


fn expect(pos, filePos, fileContent) {
  let x = 0
  while (x <= len(pos)){
    if (pos[x] != fileContent[filePos]) {
        return false
    }
    x += 1
  }
  return true
}

fn check(looking, filePos, fileContent) {
  let x = 0
  while (x <= len(looking)) {
    // x = x+1
    filePos = filePos + 1
    if (looking[x] != fileContent[filePos]) {
      return false
    }
  }
  return true
}

fn skipWS(filePos, fileContent){
  while (fileContent[filePos] == " " || fileContent[filePos] == "\t" || fileContent[filePos] == "\n") {
    filePos = filePos + 1
  }
  // Check bounds before accessing fileContent[filePos + 1]
  if (filePos + 1 < len(fileContent) && fileContent[filePos] == "/" && fileContent[filePos + 1] == "/") {
    while (fileContent[filePos] != "\n") {
      filePos += 1
    }
    filePos = filePos+1
  }
  if (filePos + 1 < len(fileContent) && fileContent[filePos] == "/" && fileContent[filePos+1] == "*") {
    while (filePos + 1 < len(fileContent) && (fileContent[filePos] != "*" && fileContent[filePos+1] != "/")) {
      filePos = filePos + 1
    }
    // Move past the closing */ if (found
    if (filePos + 1 < len(fileContent)) {
      filePos = filePos + 2
    }
  }
  return filePos
}

u8 pack(u8 reg, u8 op) -> constexpr {
  return ((reg << 4) | op);
}

u8 IMPORTED_FUNC  = 0x01
u8 IMPORTED_LOAD = 0x02
u8 IMPORTED_STORE = 0x03
u8 NOP = 0x04
u8 PUSH_I = 0x05
u8 PUSH_F = 0x06
u8 PUSH_B = 0x07
u8 PUSH_S = 0x08
u8 PUSH_C = 0x09
u8 PUSH_N = 0x0A
u8 MAKE_LIST = 0x0B
u8 GET = 0x0C
u8 SET = 0x0D
u8 DECL = 0x0E
u8 POP = 0x0F
u8 ADD = 0x10
u8 SUB = 0x11
u8 MUL = 0x12
u8 DIV = 0x13
u8 NEG = 0x14
u8 EQ = 0x15
u8 NE = 0x16
u8 LT = 0x17
u8 LE = 0x18
u8 AND = 0x19
u8 OR = 0x1A
u8 JMP = 0x1B
u8 JF = 0x1C
u8 CALL = 0x1D
u8 RET = 0x1E
u8 RET_VOID = 0x1F
u8 HALT = 0x20
u8 UNSET = 0x21
u8 SLICE = 0x22
u8 INDEX = 0x23
u8 SET_INDEX = 0x24
u8 TAIL = 0x25
u8 YIELD = 0x26
u8 NOT = 0x27

fn isDigit(c) {
  if (c >= "0" && c <= "9") {
    return true
  }
  return false
}

fn isAlpha(c) {
  if (c == "a" |= "b" |= "c" |= "d" |= "e" |= "f"|= "g"|= "h"|= "i"|= "j"|= "k"|= "l"|= "m"|= "n"|= "o"|= "p"|= "q"|= "r"|= "s"|= "t" |= "u"|= "v" |= "w" |= "x" |= "y" |= "z") {
    return true
  }
  if (c == "A" |= "B" |= "C" |= "D" |= "E" |= "F"|= "G"|= "H"|= "I"|= "J"|= "K"|= "L"|= "M"|= "N"|= "O"|= "P"|= "Q"|= "R"|= "S"|= "T"|= "U"|= "V" |= "W" |= "X" |= "Y" |= "Z") {
    return true
  }
  return false
}

fn parseType(POS, fileContent) {
  if (check("int ", POS, fileContent)) {
    return "int"
  }
elif (check("bool ", POS, fileContent)) {
    return "bool"
  }
elif (check("list ", POS, fileContent)) {
    return "list"
  } elif (check("str ", POS, fileContent)) {
    return "str"
  } elif (check("null ", POS, fileContent)) {
    return "null"
  } elif (check("auto ", POS, fileContent)) {
    let x = POS
    while (fileContent[x] != ";") {
      x = x + 1
    }
    while (fileContent[x] != " ") {
      x = x - 1
    }
    if (fileContent[x] == "\"") {
      return "str"
    }
    elif (fileContent[x] == "e") {
      let y = x
      if (fileContent[y-1] == "u") {
        if (fileContent[y-2] == "r") {
          if (fileContent[y-3] == "t") {
            if (fileContent[y-4] == " " || fileContent[y-4] == "=") {
              return "bool"
            }
          }
        }
      } elif (fileContent[y-1] == "s") {
        if (fileContent[y-2] == "l") {
          if (fileContent[y-3] == "a") {
            if (fileContent[y-4] == "f") {
              if (fileContent[y-5] == " " |= "=" |= "\""){
                if (fileContent[y-5] != "\"") {
                  return "bool"
                }
                else {
                  return "str"
                }
              }
            }
          }
        }
      }
    }
    if (isDigit(fileContent[x])) {
      let y = x
      while (fileContent[y] != " " || fileContent[y] != "." || fileContent[y] != "="  || fileContent[y-5] == "="){
        y = y - 1
      }
      // Continue on until we see = or ", if " warn and give string :)
      // if =, give back float! :D
      if (fileContent[y] == ".") {
        while (false) {
          return;
        }
      }
    }
  }
}

fn compile(POS, code, fileContent){
  // FIXME: We need to mark this as entry
  if (check("func ")) {
    POS += 5
    POS = skipWS(POS, code)
    compile()
  }

  elif (check("yield", POS, fileContent)) {
      POS += 5
      dev.emitU16(out, YIELD)
      if (expect(";", POS, fileContent)) {
        POS = POS + 1
      } else {
        // FIXME: Make it emit an actual error
        print("Expected ';'")
      }
  }

  elif (check("let ", POS, fileContent)) {
      POS += 4
      POS = skipWS(POS, code)
      let name = ""
      if (check("int ", POS, fileContent)) {
        dev.emitU16(out, PUSH_I)
        //dev.
      } elif (check("str ", POS, fileContent)) {
        // dev.emitU16(out, PUSH_S) or dev.emitStr(out, ...)
        continue
      }
elif (check("bool ", POS, fileContent)) {
        // dev.emitU8(out, PUSH_B) or similar
        continue
      } elif (check("null ", POS, fileContent)) {
        continue
        // dev.emitU8(out, PUSH_N)
      } elif (check("list ", POS, fileContent)) {
        continue
        // dev.emitU8(out, PUSH_LIST) and items
      } elif (check("float ", POS, fileContent)) {
        continue
        // dev.emitU8(out, PUSH_F) and value
      } elif (check("auto ", POS, fileContent)) {
        POS += 5
        POS = skipsWS(POS)

        while (fileContent != "=" && fileContent != ";" && fileContent != " ") {
          name = name + fileContent[POS]
          POS = POS + 1
        }
        POS = skipsWS(POS, fileContent)
        if (fileContent[POS] == ";") {
          dev.emitU16(out, PUSH_N)
          dev.emitU16(out, DECL)
          dev.emitStr(out, name)

        }
        if (check("=", POS, fileContent)) {
          POS = POS + skipsWS(POS, fileContent)
          continue

        }
      } else {
        // handle error
        continue
      }
  } else {
    // Anything else, var++; var += etc.
    // Eventually remove let
    continue
  }
}
while (POS <= len(code)) {
  compile(POS, code, fileContent)
}

int main(u16 argc, list argv) {
  unordered dict flags = {
    bool debug:false,
  }

  for arg in 1..argc {
    // If debug is true, skip :)
    debug ? continue : argv[arg] == "-g" ? debug = true : continue

  }
}
