import dev

// Open input file (read as string)
let code = open("mini.mi", "r")
code = read(code)
let out = dev.openFile("testing.mbc")
POS = skipWS(0, code)


fn expect(pos, filePos, fileContent) {
  let x = 0
  while (x <= len(pos)){
    if (pos[x] != fileContent[filePos]) {
        return false
    }
    x += 1
  }
  return true
  del x
}

fn check(looking, filePos, fileContent) {
  let x = 0
  while (x <= len(looking)) {
    // x = x+1
    filePos = filePos + 1
    if (looking[x] != fileContent[filePos]) {
      del x
      return false
    }
  }
  del x
  return true
}

fn skipWS(filePos, fileContent){
  while (fileContent[filePos] == " " || fileContent[filePos] == "\t" || fileContent[filePos] == "\n") {
    filePos = filePos + 1
  }
  // Check bounds before accessing fileContent[filePos + 1]
  if (filePos + 1 < len(fileContent) && fileContent[filePos] == "/" && fileContent[filePos + 1] == "/") {
    while (fileContent[filePos] != "\n") {
      filePos += 1
    }
    filePos = filePos+1
  }
  if (filePos + 1 < len(fileContent) && fileContent[filePos] == "/" && fileContent[filePos+1] == "*") {
    while (filePos + 1 < len(fileContent) && (fileContent[filePos] != "*" && fileContent[filePos+1] != "/")) {
      filePos = filePos + 1
    }
    // Move past the closing */ if (found
    if (filePos + 1 < len(fileContent)) {
      filePos = filePos + 2
    }
  }
  return filePos
}

let IMPORTED_FUNC  = 0x01
let IMPORTED_LOAD = 0x02
let IMPORTED_STORE = 0x03
let NOP = 0x04
let PUSH_I = 0x05
let PUSH_F = 0x06
let PUSH_B = 0x07
let PUSH_S = 0x08
let PUSH_C = 0x09
let PUSH_N = 0x0A
let MAKE_LIST = 0x0B
let GET = 0x0C
let SET = 0x0D
let DECL = 0x0E
let POP = 0x0F
let ADD = 0x10
let SUB = 0x11
let MUL = 0x12
let DIV = 0x13
let NEG = 0x14
let EQ = 0x15
let NE = 0x16
let LT = 0x17
let LE = 0x18
let AND = 0x19
let OR = 0x1A
let JMP = 0x1B
let JF = 0x1C
let CALL = 0x1D
let RET = 0x1E
let RET_VOID = 0x1F
let HALT = 0x20
let UNSET = 0x21
let SLICE = 0x22
let INDEX = 0x23
let SET_INDEX = 0x24
let TAIL = 0x25
let YIELD = 0x26
let NOT = 0x27

fn isDigit(c) {
  if (c >= "0" && c <= "9") {
    return true
  }
  return false
}

fn isAlpha(c) {
  if (c == "a" |= "b" |= "c" |= "d" |= "e" |= "f"|= "g"|= "h"|= "i"|= "j"|= "k"|= "l"|= "m"|= "n"|= "o"|= "p"|= "q"|= "r"|= "s"|= "t" |= "u"|= "v" |= "w" |= "x" |= "y" |= "z") {
    return true
  }
  if (c == "A" |= "B" |= "C" |= "D" |= "E" |= "F"|= "G"|= "H"|= "I"|= "J"|= "K"|= "L"|= "M"|= "N"|= "O"|= "P"|= "Q"|= "R"|= "S"|= "T"|= "U"|= "V" |= "W" |= "X" |= "Y" |= "Z") {
    return true
  }
  return false
}

fn parseType(POS, fileContent) {
  if (check("int ", POS, fileContent)) {
    return "int"
  }
elif (check("bool ", POS, fileContent)) {
    return "bool"
  }
elif (check("list ", POS, fileContent)) {
    return "list"
  } elif (check("str ", POS, fileContent)) {
    return "str"
  } elif (check("null ", POS, fileContent)) {
    return "null"
  } elif (check("auto ", POS, fileContent)) {
    let x = POS
    while (fileContent[x] != ";") {
      x = x + 1
    }
    while (fileContent[x] != " ") {
      x = x - 1
    }
    if (fileContent[x] == "\"") {
      return "str"
    }
    elif (fileContent[x] == "e") {
      let y = x
      if (fileContent[y-1] == "u") {
        if (fileContent[y-2] == "r") {
          if (fileContent[y-3] == "t") {
            if (fileContent[y-4] == " " || fileContent[y-4] == "=") {
              return "bool"
            }
          }
        }
      } elif (fileContent[y-1] == "s") {
        if (fileContent[y-2] == "l") {
          if (fileContent[y-3] == "a") {
            if (fileContent[y-4] == "f") {
              if (fileContent[y-5] == " " |= "=" |= "\""){
                if (fileContent[y-5] != "\"") {
                  return "bool"
                }
                else {
                  return "str"
                }
              }
            }
          }
        }
      }
      del y
    }
    if (isDigit(fileContent[x])) {
      let y = x
      while (fileContent[y] != " " || fileContent[y] != "." || fileContent[y] != "="  || fileContent[y-5] == "="){
        y = y - 1
      }
      // Continue on until we see = or ", if " warn and give string :)
      // if =, give back float! :D
      if (fileContent[y] == ".") {
        while (false) {
          return;
        }
      }
    }
  }
}

fn compile(POS, code, fileContent){
  // FIXME: We need to mark this as entry
  if (check("func ")) {
    POS += 5
    POS = skipWS(POS, code)
    compile()
  }

  elif (check("yield", POS, fileContent)) {
      POS += 5
      dev.emitU16(out, YIELD)
      if (expect(";", POS, fileContent)) {
        POS = POS + 1
      } else {
        // FIXME: Make it emit an actual error
        print("Expected ';'")
      }
  }

  elif (check("let ", POS, fileContent)) {
      POS += 4
      POS = skipWS(POS, code)
      let name = ""
      if (check("int ", POS, fileContent)) {
        dev.emitU16(out, PUSH_I)
        //dev.
      } elif (check("str ", POS, fileContent)) {
        // dev.emitU16(out, PUSH_S) or dev.emitStr(out, ...)
        continue
      }
elif (check("bool ", POS, fileContent)) {
        // dev.emitU8(out, PUSH_B) or similar
        continue
      } elif (check("null ", POS, fileContent)) {
        continue
        // dev.emitU8(out, PUSH_N)
      } elif (check("list ", POS, fileContent)) {
        continue
        // dev.emitU8(out, PUSH_LIST) and items
      } elif (check("float ", POS, fileContent)) {
        continue
        // dev.emitU8(out, PUSH_F) and value
      } elif (check("auto ", POS, fileContent)) {
        POS += 5
        POS = skipsWS(POS)

        while (fileContent != "=" && fileContent != ";" && fileContent != " ") {
          name = name + fileContent[POS]
          POS = POS + 1
        }
        POS = skipsWS(POS, fileContent)
        if (fileContent[POS] == ";") {
          dev.emitU16(out, PUSH_N)
          dev.emitU16(out, DECL)
          dev.emitStr(out, name)

        }
        if (check("=", POS, fileContent)) {
          POS = POS + skipsWS(POS, fileContent)
          continue

        }
      } else {
        // handle error
        continue
      }
  } else {
    // Anything else, var++; var += etc.
    // Eventually remove let
    continue
  }
}
while (POS <= len(code)) {
  compile(POS, code, fileContent)
}
