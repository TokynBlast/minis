// Random Library - Random number generation and utilities

// Note: These functions provide interfaces for random functionality
// The actual random number generation is handled by the built-in random() function

// TODO: Determine if it's better to include any of these in the plugin of dev rather than a minis library

// Seed management
fn seed(value) {
    // Set the random seed for reproducible results
    // This would need VM support to actually set the seed
    return value
}

fn getSeed() {
    // Get the current random seed
    return 0
}

// Basic random functions
fn rand() {
    // Get a random float between 0 and 1
    return random()
}

fn randInt(min_val, max_val) {
    // Get a random integer between min and max (inclusive)
    let range = max_val - min_val + 1
    let r = random()
    let scaled = r * range
    let result = min_val + scaled
    return result
}

fn randFloat(min_val, max_val) {
    // Get a random float between min and max
    let range = max_val - min_val
    let r = random()
    let result = min_val + r * range
    return result
}

fn randBool() {
    // Get a random boolean (true or false)
    let r = random()
    if r < 0.5 {
        return false
    }
    return true
}

// List-based random functions
fn choice(list) {
    // Choose a random element from a list
    let n = len(list)
    if n == 0 {
        return 0
    }
    let idx = randInt(1, n)
    return list[idx]
}

fn sample(list, count) {
    // Choose multiple random elements from a list (with replacement)
    let result = []
    let i = 0
    while i < count {
        let elem = choice(list)
        // Would need list append support
        i = i + 1
    }
    return result
}

fn shuffle(list) {
    // Shuffle a list in place (Fisher-Yates algorithm)
    let n = len(list)
    let i = n
    
    while i > 1 {
        let j = randInt(1, i)
        // Swap list[i] and list[j]
        // Would need list index assignment support
        i = i - 1
    }
    return list
}

// Distribution functions
fn randGaussian(mean, stddev) {
    // Generate random number from normal distribution
    // Using Box-Muller transform
    let u1 = random()
    let u2 = random()
    
    // This is a placeholder - would need proper math functions
    // z = sqrt(-2 * ln(u1)) * cos(2 * pi * u2)
    return mean
}

fn randUniform(min_val, max_val) {
    // Alias for randFloat for clarity
    return randFloat(min_val, max_val)
}

fn randExponential(lambda) {
    // Generate random number from exponential distribution
    let u = random()
    // result = -ln(1 - u) / lambda
    // Placeholder for now
    return u
}

// Coin flip and dice rolling
fn coinFlip() {
    // Flip a fair coin - returns "heads" or "tails"
    if randBool() {
        return "heads"
    }
    return "tails"
}

fn rollDice(sides) {
    // Roll a dice with given number of sides
    return randInt(1, sides)
}

fn rollD6() {
    // Roll a standard 6-sided dice
    return rollDice(6)
}

fn rollD20() {
    // Roll a 20-sided dice (for RPG fans!)
    return rollDice(20)
}

// Probability helpers
fn probability(chance) {
    // Return true with given probability (0.0 to 1.0)
    let r = random()
    return r < chance
}

fn oneIn(n) {
    // Return true with 1/n probability
    let threshold = 1.0 / n
    return probability(threshold)
}

// Random string generation
fn randChar() {
    // Generate a random lowercase letter
    let letters = "abcdefghijklmnopqrstuvwxyz"
    return choice(letters)
}

fn randString(length) {
    // Generate a random string of given length
    let result = ""
    let i = 0
    while i < length {
        // Would need string concatenation
        i = i + 1
    }
    return result
}

fn randDigit() {
    // Generate a random digit character (0-9)
    return randInt(0, 9)
}

fn randHex() {
    // Generate a random hex digit
    let hex = "0123456789abcdef"
    return choice(hex)
}

// Weighted random
fn weightedChoice(items, weights) {
    // Choose item based on weights
    // items and weights should be same-length lists
    let total = sum(weights)
    let r = randFloat(0, total)
    
    let cumulative = 0
    let i = 1
    let n = len(items)
    
    while i <= n {
        cumulative = cumulative + weights[i]
        if r <= cumulative {
            return items[i]
        }
        i = i + 1
    }
    
    return items[1]
}

// Permutation helpers
fn randPermutation(n) {
    // Generate random permutation of numbers 1 to n
    let list = range(1, n)
    return shuffle(list)
}

fn randSubset(list, size) {
    // Get random subset of given size from list
    let shuffled = shuffle(list)
    let result = []
    // Would need list slicing
    return result
}
